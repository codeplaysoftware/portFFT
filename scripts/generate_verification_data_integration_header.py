"""************************************************************************
 *
 *  Copyright (C) Codeplay Software Ltd.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  Codeplay's SYCL-FFT
 *
 ************************************************************************"""
from pathlib import Path

template_begins = """
/***************************************************************************
 *
 *  Generated by scripts/generate_verification_data_integration_header.py. Do not edit!
 *
 **************************************************************************/

#ifndef SYCL_FFT_{include_guard_str}_HPP
#define SYCL_FFT_{include_guard_str}_HPP
#include "reference_data_wrangler.hpp"

const std::vector<verif_data_spec> verification_data({{
"""

template_per_item = """
    verif_data_spec(
        {{ {dft_sizes_str} }},
        {batch_str},
        "{file_str}",
        {is_complex_str}
    ),
"""

template_ends = """
}});

#endif
"""


def generate_header_string(config_dicts, output_file_path, header_guard_name):
    """Generate a C++ header file detailing the configurations given
    in config_dicts, writing to the output_file_path, using header guards
    given in header_guard_name.
    """

    file_path = Path(output_file_path)
    try:
        file_path.parent.mkdir(exist_ok=True, parents=True)
        file_path.touch()
    except Exception as e:
        raise Exception("Could not write header file to " + str(file_path))
    with file_path.open("w") as f:
        f.write(template_begins.format(include_guard_str=header_guard_name))
        for d in config_dicts:
            # Turn Python's string for dimensions into one useful for the constructor.
            dftSizesStr = str(d["input_dimensions"]).replace(" ", "").replace(
                "[", "").replace("]", "")
            batch_string = str(d["batch"])
            file_string = str(d["file_path"])
            domain_bool = "sycl_fft::domain::COMPLEX" if d[
                "transform_type"] == "COMPLEX" else "sycl_fft::domain::REAL"
            f.write(
                template_per_item.format(dft_sizes_str=dftSizesStr,
                                         batch_str=batch_string,
                                         file_str=file_string,
                                         is_complex_str=domain_bool))
        f.write(template_ends.format())
