"""************************************************************************
 *
 *  Copyright (C) Codeplay Software Ltd.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  Codeplay's SYCL-FFT
 *
 ************************************************************************"""
import math
MAX_SIZE = 64
DST = "./src/common/twiddle.hpp"

template = """
/***************************************************************************
 *
 *  Generated by scripts/generate_twiddles.py. Do not edit!
 *
 **************************************************************************/

#ifndef SYCL_FFT_COMMON_TWIDDLE_HPP
#define SYCL_FFT_COMMON_TWIDDLE_HPP

namespace sycl_fft::detail{{

template<typename T>
struct twiddle{{
// twiddle_re[N][K] and twiddle_im[N][K] contain real and imaginary components of a twiddle factor K out of N.

// We only have twiddles up to size 64 here. 64 is likely the largest size we will be able to handle within one workitem on current GPUs
//clang-format off

static constexpr T re[{size}][{size}] = {{ {real_forward} }};

static constexpr T im[{size}][{size}] = {{ {imag_forward} }};

//clang-format on
}};
}}

#endif
"""

def generate(max_size):
    res_real_forward = []
    res_imag_forward = []
    for size in range(max_size+1):
        tmp_real_forward = []
        tmp_imag_forward = []
        for i in range(size):
            # make sure zeros are exact to let compiler do further optimizations
            if i == 0:
                tmp_real_forward.append(1.0)
                tmp_imag_forward.append(0.0)
            elif 2*i == size:
                tmp_real_forward.append(-1.0)
                tmp_imag_forward.append(0.0)
            elif 4*i == size:
                tmp_real_forward.append(0.0)
                tmp_imag_forward.append(-1.0)
            elif 4*i == size*3:
                tmp_real_forward.append(0.0)
                tmp_imag_forward.append(1.0)
            else:
                theta = -2. * math.pi * i / size
                tmp_real_forward.append(math.cos(theta))
                tmp_imag_forward.append(math.sin(theta))

        # pad with zeros to max_size
        tmp_real_forward += [0] * (max_size - size + 1)
        tmp_imag_forward += [0] * (max_size - size + 1)

        res_real_forward.append(tmp_real_forward)
        res_imag_forward.append(tmp_imag_forward)
    
    return [res_real_forward, res_imag_forward]


def write(path, size):
    real_forward, imag_forward  = generate(size)
    with open(path, "w") as fil:
        realstr_forward = ",\n".join("{" + ", ".join(str(j)
                                                     for j in i) + "}" for i in real_forward)
        imagstr_forward = ",\n".join("{" + ", ".join(str(j)
                                                     for j in i) + "}" for i in imag_forward)
        
        content = template.format(size=size+1, real_forward=realstr_forward, imag_forward=imagstr_forward)
        fil.write(content)


if __name__ == "__main__":
    write(DST, MAX_SIZE)
